#!/usr/bin/env python
# -*- coding: utf-8 -*-

 # no more "zero" integer division bugs!:P
import argparse
import os
import time
import glob
import sys
import datetime
# os: operating system | time: execution time | glob: globbing file...loading multiple files as *.pippa | sys: system...boh | datetime: day and so...
import numpy as np # array
#sys.path.append("/media/Data/Dropbox/Dottorato/pyscript")
#sys.path.append("../")
#from path_check import checkpath
import constants as cst
import ancillary as anc
# --------------------------------------------------------------------------

# WARNING
# TO FIX

# --------------------------------------------------------------------------
# THIS SCRIPT READ THE #_finalXpar.dat GENERATED BY TRADES AND CONVERT
# THE MASSES FROM SUN TO JUPITER/NEPTUNE/EARTH MASSES AND PRINT ALL THE
# CALCULATED PARAMETERS IN FILE
# IT CAN READ THE DATA FROM BOOTSTRAP ANALYSIS AND IT WRITES PROPERLY THE
# FILE
# --------------------------------------------------------------------------


# sigma          -3     -2      -1       0    1       2       3       1
# sigma pos       0      1       2       3    4       5       6       7
percentile_val = [0.135, 2.265, 15.865, 50.0, 84.135, 97.735, 99.865, 68.27]
n_percentile = len(percentile_val)
deg2rad = np.pi/180.0
rad2deg = 180.0/np.pi

eps64bit = np.finfo(np.float64(1.0)).eps
eps32bit = np.finfo(np.float32(1.0)).eps

# ---
# w/ argparse
def get_args():
  parser = argparse.ArgumentParser()
  parser.add_argument('-p', action='store', dest='fpath', required=True, help='Folder path')
  parser.add_argument('-s', action='store', dest='idsim', required=True, help='Simulation ID number')
  parser.add_argument('-lm', action='store', dest='lmflag', default='0', help='LM flag: 0 = not used LM (default), 1 = used LM')
  parser.add_argument('-b', '--bootstrap', action='store', dest='boot', default=True, help='Bootsrap flag: "0" or "no" or "n" or "False", "1" or "yes" or "y" or "True", default = True')
  parser.add_argument('-m', '--m-type', '--mass-type', action='store', dest='mtype', default='j', help='Mass type to use: e = Earth, j = Jupiter, n = Neptune, s = Sun')
  parser.add_argument('-mg', '--m-gauss', '--mass-gaussian', action='store', dest='mgauss', default='True', help='If used old version of TRADES set it to "0" or "no" or "n" or "False", else it assumes that the masses of planets are scaled by the mass of star during the fit. Default is "1" or "yes" or "y" or "True".')
  parser.add_argument('--seed', action='store', dest='seed', default='None', help='Seed to generate Gaussian distribution of Mstar. If -mg is False it is not need. Default is None.')
  parser.add_argument('-ft', '--fit-type', action='store', dest='fit_type', default='hk', help='Fitting type: hk = (ecosw, esinw), ew = (e, w), sew = (sqrtecosw, sqrtesinw). Default = hk, BUT IT IS NOT USED!')
  
  cli = parser.parse_args()
  
  noList  = ["0", "no",  "n", "False", False]
  yesList = ["1", "yes", "y", "True",  True]
  if (cli.boot in yesList ):
    print(" BOOTSTRAP INTERVALS: YES")
    cli.boot = True
  else:
    print(" BOOTSTRAP INTERVALS: NO")
    cli.boot = False
    
  mList = ["e", "j", "s", "n"]
  if not(cli.mtype in mList):
    print(" INSERTED INVALID MASS TYPE ARGUMENT: %s" %(cli.mtype))
    cli.mtype = "j"
    print(" MASS TYPE HAS BEEN SET TO DEFAULT: j = Jupiter")
    
    
  if (cli.mgauss in noList):
    cli.mgauss = False
    print(' DO NOT SCALE MASS FIT BY N(Mstar, sigma_Mstar)')
  else:
    cli.mgauss = True
    print(' DO SCALE MASS FIT BY N(Mstar, sigma_Mstar)')
    
  #if (cli.lmflag == '1'):
    #cli.fit_type = 'hk'
  
  cli.fpath = os.path.abspath(cli.fpath)
  
  if(str(cli.seed).lower() == 'none'):
    cli.seed = None
  else:
    try:
      cli.seed = int(cli.seed)
    except:
      cli.seed = None
  
  return cli
  #return cli.fpath, cli.idsim, cli.lmflag, cli.boot, cli.mtype, cli.mgauss, cli.fit_type

# ---
def parameters_file(fpath, idsim, lmf):
  f0 = str(idsim) + "_" + str(lmf) + "_final*.dat"
  #f1 = glob.glob(fpath + f0)
  f1 = glob.glob(os.path.join(fpath, f0))
  file_par = os.path.abspath(f1[0])
  return file_par


# ---
# read #_final#par.dat from the TRADES fit
def read_parameters(file_par, lmf):
  print(" Reading file ")
  print(" Parameters: %s" %(file_par))
  names_par = []
  par = []
  fitness_s, fitness_x_dof_s, bic, chi2 = 'NONE', 'NONE', 'NONE','NONE'
  ndata='NONE'
  #sig_par = []
  ofpar = open(file_par, 'r')
  for line in ofpar:
    if (line.find("Fitness(") != -1):
      fitness_s = line.strip("\n").split(" => ")[0].strip(" ").split("=")[1].strip()
      fitness_x_dof_s = line.strip("\n").split("Fitness_x_dof = ")[1].split("dof")[0].strip()
      dof = line.strip("\n").split(" dof = ")[1].strip()
      #dof = line.strip("\n").split()[-1].strip()
    if (line.find("BIC") != -1):
      try:
        #bic = line.strip("\n").split("BIC = Fitness_x_dof + nfit x ln(ndata) = ")[1]
        bic = line.strip("\n").split()[-1].strip()
        chi2 = line.strip("\n").split("=")[2].split(" + ")[0].strip()
        ndata = line.strip("\n").split("ln(")[2].split(")")[0].strip()
      except:
        bic = 'NONE'
        chi2 = 'NONE'
    if line[0] != "#":
      wline = line.strip("\n")
      names_par.append(wline.split()[0])
      par.append(wline.split()[1])
      #if(str(lmf) == '1'):
        #sig_par.append(wline.split()[2])
      #else:
        #sig_par.append("0.0")
  ofpar.close()
  #return names_par, np.array(par).astype('f8'), np.array(sig_par).astype('f8'), fitness_s, fitness_x_dof_s, dof
  return names_par, np.array(par).astype('f8'), fitness_s, fitness_x_dof_s, bic, chi2, ndata, dof

# ---
def get_MR_start(fpath, star_file):
  #o_bd = open(os.path.join(fpath, 'bodies.lst'))
  #star_line = o_bd.readline().strip()
  #o_bd.close()
  #star_file = star_line.split()[0]
  MR_star = np.genfromtxt(os.path.join(fpath, star_file), dtype=np.float64)
  return MR_star


def main():
  # =================================================================================
  # MAIN

  print("")
  print(" --- read_finalpar_v2.py --- ")
  print("")

  cli = get_args()
  fpath, idsim, lmflag, boot, mtype, mgauss, fit_type = cli.fpath, cli.idsim, cli.lmflag, cli.boot, cli.mtype, cli.mgauss, cli.fit_type

  nfit, NB, bodies_file, id_fit, id_all, nfit_list, cols_list, case_list = anc.get_fitted(fpath)

  MR_star = get_MR_start(fpath, bodies_file[0])
  if(len(MR_star.shape)==2):
    Mstar = MR_star[0,0]
  else:
    Mstar = MR_star[0].copy()
    MR_star = np.zeros((2,2))
    MR_star[0,0] = Mstar

  if(boot):
    file_boot = os.path.join(fpath, '%s_bootstrap_sim.dat' %(idsim))
    try:
      bootstrap = np.genfromtxt(file_boot)[:,1:]
    except:
      sys.exit(' CANNOT FIND BOOTSTRAP FILE: %s' %(file_boot))
    if(mgauss):
      m_factor, mass_unit = anc.mass_type_factor(Ms=Mstar, mtype=mtype, mscale=True)
      m_factor_boot = m_factor
    else:
      m_factor, mass_unit = anc.mass_type_factor(Ms=1.0, mtype=mtype, mscale=False)
      np.random.seed(seed=cli.seed)
      Ms_gaussian = MR_star[0,0] + np.random.normal(0., 1., size=(np.shape(bootstrap)[0]))*MR_star[0,1] # if exists an error on the mass, it creates a Normal distribution for the values and use it to re-scale mp/Ms to mp.
      m_factor_boot = m_factor * Ms_gaussian # given the factor from Msun to mass_unit it multiply it by the Normal Mstar.
      m_factor = m_factor * MR_star[0,0]
  else:
    bootstrap = None
    m_factor, mass_unit = anc.mass_type_factor(Ms=Mstar, mtype=mtype, mscale=True)
  
  kel_file, kep_elem = anc.elements(fpath, int(idsim), int(lmflag))

  file_par = parameters_file(fpath, idsim, lmflag)
  names_par, par, fitness_s, fitness_x_dof_s, bic, chi2, ndata, dof = read_parameters(file_par, lmflag)

  #if (boot):
    #file_boot = os.path.join(fpath, '%s_bootstrap_sim.dat' %(idsim))
    #try:
      #bootstrap = np.genfromtxt(file_boot)[:,1:]
    #except:
      #sys.exit(' CANNOT FIND BOOTSTRAP FILE: %s' %(file_boot))
  #else:
    #bootstrap = None
    
  units_par = anc.get_units(names_par, mass_unit)
  names_derived, derived_par = anc.compute_derived_parameters(names_par, kep_elem, id_fit, case_list, cols_list, par, conv_factor=m_factor)
  units_der = anc.get_units(names_derived, mass_unit)

  if(boot):
    sigma_par = anc.compute_intervals(bootstrap, par, anc.percentile_val)
    names_derived, der_posterior = anc.compute_derived_posterior(names_par, kep_elem, id_fit, case_list, cols_list, bootstrap, conv_factor=m_factor_boot)
    derived_par, der_posterior = anc.adjust_derived_parameters(names_derived, derived_par, der_posterior)
    sigma_derived = anc.compute_intervals(der_posterior, derived_par, anc.percentile_val)
  else:
    sigma_par = None
    sigma_derived = None
    
  output_file = '%s_%s.log' %(os.path.splitext(file_par)[0], mass_unit)
  out = open(output_file, 'w')

  top_header, header = anc.get_header(anc.percentile_val)

  # print to screen and into file
  anc.print_both('', out)
  anc.print_both('# Number of bodies = %d' %(NB), out)
  anc.print_both('# OUTPUT FILE: %s' %(output_file), out)
  anc.print_both('# fitness = %s' %(fitness_s), out)
  anc.print_both('# fitness x dof = %s' %(fitness_x_dof_s), out)
  anc.print_both('# bic = %s' %(bic), out)
  anc.print_both('# chi2 = %s' %(chi2), out)
  anc.print_both('# ndata = %s' %(ndata), out)
  anc.print_both('# dof = %s' %(dof), out)
  anc.print_both('# Mstar = %.4f +/- %.4f M_sun' %(MR_star[0,0], MR_star[0,1]), out)
  anc.print_both('# FITTED PARAMETERS (nfit = %d)' %(nfit), out)
  
  
  anc.print_both('# FITTED PARAMETERS', out)
  anc.print_parameters(top_header, header, names_par, units_par, par, sigma_par, out)
  
  anc.print_both('# DERIVED PARAMETERS', out)
  anc.print_parameters(top_header, header, names_derived, units_der, derived_par, sigma_derived, out)
  out.close()
  
  return

if __name__ == "__main__":
  main()



  
